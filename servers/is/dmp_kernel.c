/*
 *  Copyright (C) 2011  Ladislav Klenovic <klenovic@nucleonsoft.com>
 *
 *  This file is part of Nucleos kernel.
 *
 *  Nucleos kernel is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, version 2 of the License.
 */
/* Debugging dump procedures for the kernel. */
#include <nucleos/kernel.h>
#include "inc.h"
#include <nucleos/timer.h>
#include <nucleos/endpoint.h>
#include <nucleos/sysutil.h>
#include <kernel/const.h>
#include <kernel/types.h>
#include <kernel/proc.h>
#include <asm/irq_vectors.h>

#define LINES 22

#define PRINTRTS(rp) { \
	char *procname = "";	\
	printk(" %s", p_rts_flags_str(rp->p_rts_flags));	\
	if (rp->p_rts_flags & RTS_SENDING)				\
		procname = proc_name(_ENDPOINT_P(rp->p_sendto_e)); \
	else if (rp->p_rts_flags & RTS_RECEIVING)			\
		procname = proc_name(_ENDPOINT_P(rp->p_getfrom_e)); \
	printk(" %-7.7s", procname);	\
}

static int pagelines;

#define PROCLOOP(rp, oldrp) \
	pagelines = 0; \
	for (rp = oldrp; rp < END_PROC_ADDR; rp++) { \
	  oldrp = BEG_PROC_ADDR; \
	  if (isemptyp(rp)) continue; \
	  if (++pagelines > LINES) { oldrp = rp; printk("--more--\n"); break; }\
	  if (proc_nr(rp) == IDLE) 	printk("(%2d) ", proc_nr(rp));  \
	  else if (proc_nr(rp) < 0) 	printk("[%2d] ", proc_nr(rp)); 	\
	  else 				printk(" %2d  ", proc_nr(rp));

#define click_to_round_k(n) \
	((unsigned) ((((unsigned long) (n) << CLICK_SHIFT) + 512) / 1024))

/* Declare some local dump procedures. */
static char *proc_name(int proc_nr);
static char *s_traps_str(int flags);
static char *s_flags_str(int flags);
static char *p_rts_flags_str(int flags);
static char *boot_flags_str(int flags);

/* Some global data that is shared among several dumping procedures. 
 * Note that the process table copy has the same name as in the kernel
 * so that most macros and definitions from proc.h also apply here.
 */
struct proc proc[NR_TASKS + NR_PROCS];
struct priv priv[NR_SYS_PROCS];
struct boot_image image[NR_BOOT_PROCS];

/*===========================================================================*
 *				timing_dmp				     *
 *===========================================================================*/
void timing_dmp()
{
	static struct util_timingdata timingdata[TIMING_CATEGORIES];
	int r, c, x = 0;

	if ((r = sys_getlocktimings(&timingdata[0])) != 0) {
		report("IS","warning: couldn't get copy of lock timings", r);
		return;
	}

  for(c = 0; c < TIMING_CATEGORIES; c++) {
	int b;
	if (!timingdata[c].lock_timings_range[0] || !timingdata[c].binsize)
		continue;
	x = printk("%-*s: misses %lu, resets %lu, measurements %lu: ",
	TIMING_NAME, timingdata[c].names,
		timingdata[c].misses,
		timingdata[c].resets,
		timingdata[c].measurements);
	for(b = 0; b < TIMING_POINTS; b++) {
		int w;
		if (!timingdata[c].lock_timings[b])
			continue;
		x += (w = printk(" %5d: %5d", timingdata[c].lock_timings_range[0] +
			b*timingdata[c].binsize,
			timingdata[c].lock_timings[b]));
	 	if (x + w >= 80) { printk("\n"); x = 0; }
	}
  	if (x > 0) printk("\n");
  }
}

/*===========================================================================*
 *				kmessages_dmp				     *
 *===========================================================================*/
void kmessages_dmp()
{
	struct kmessages *kmess;	/* get copy of kernel messages */
	char *print_buf;		/* this one is used to print */
	int start;			/* calculate start of messages */
	int r;

	kmess = malloc(sizeof(struct kmessages));
	if (!kmess) {
		report("IS","Error: no enough memory", -ENOMEM);
		return;
	}

	print_buf = malloc(KMESS_BUF_SIZE+1);
	if (!print_buf) {
		report("IS","Error: no enough memory", -ENOMEM);
		goto kmessages_dmp_free_buf1;
	}

	/* Try to get a copy of the kernel messages. */
	if ((r = sys_getkmessages(kmess)) != 0) {
		report("IS","warning: couldn't get copy of kmessages", r);
		goto kmessages_dmp_free_buf2;
	}

	/* Try to print the kernel messages. First determine start and copy the
	 * buffer into a print-buffer. This is done because the messages in the
	 * copy may wrap (the kernel buffer is circular).
	 */
	start = ((kmess->km_next + KMESS_BUF_SIZE) - kmess->km_size) % KMESS_BUF_SIZE;
	r = 0;
	while (kmess->km_size > 0) {
		print_buf[r] = kmess->km_buf[(start+r) % KMESS_BUF_SIZE];
		r ++;
		kmess->km_size --;
	}

	print_buf[r] = 0;		/* make sure it terminates */
	printk("Dump of all messages generated by the kernel.\n\n");
	printk("%s", print_buf);		/* print the messages */

kmessages_dmp_free_buf2:
	free(print_buf);

kmessages_dmp_free_buf1:
	free(kmess);

	return;
}

/*===========================================================================*
 *				monparams_dmp				     *
 *===========================================================================*/
void monparams_dmp()
{
  char val[1024];
  char *e;
  int r;

  /* Try to get a copy of the boot monitor parameters. */
  if ((r = sys_getmonparams(val, sizeof(val))) != 0) {
      report("IS","warning: couldn't get copy of monitor params", r);
      return;
  }

  /* Append new lines to the result. */
  e = val;
  do {
	e += strlen(e);
	*e++ = '\n';
  } while (*e != 0); 

  /* Finally, print the result. */
  printk("Dump of kernel environment strings set by boot monitor.\n");
  printk("\n%s\n", val);
}

/*===========================================================================*
 *				irqtab_dmp				     *
 *===========================================================================*/
void irqtab_dmp()
{
  int i,r;
  struct irq_hook irq_hooks[NR_IRQ_HOOKS];
  int irq_actids[NR_IRQ_VECTORS];
  struct irq_hook *e;	/* irq tab entry */

  if ((r = sys_getirqhooks(irq_hooks)) != 0) {
      report("IS","warning: couldn't get copy of irq hooks", r);
      return;
  }
  if ((r = sys_getirqactids(irq_actids)) != 0) {
      report("IS","warning: couldn't get copy of irq mask", r);
      return;
  }

#if 0
  printk("irq_actids:");
  for (i= 0; i<NR_IRQ_VECTORS; i++)
	printk(" [%d] = 0x%08x", i, irq_actids[i]);
  printk("\n");
#endif

  printk("IRQ policies dump shows use of kernel's IRQ hooks.\n");
  printk("-h.id- -proc.nr- -irq nr- -policy- -notify id-\n");
  for (i=0; i<NR_IRQ_HOOKS; i++) {
  	e = &irq_hooks[i];
  	printk("%3d", i);
  	if (e->proc_nr_e==ENDPT_NONE) {
  	    printk("    <unused>\n");
  	    continue;
  	}
  	printk("%10d  ", e->proc_nr_e); 
  	printk("    (%02d) ", e->irq); 
  	printk("  %s", (e->policy & IRQ_REENABLE) ? "reenable" : "    -   ");
  	printk("   %d", e->notify_id);
	if (irq_actids[e->irq] & (1 << i))
		printk("masked");
	printk("\n");
  }
  printk("\n");
}

/*===========================================================================*
 *			      boot_flags_str				     *
 *===========================================================================*/
static char *boot_flags_str(int flags)
{
	static char str[10];
	str[0] = (flags & PROC_FULLVM)        ? 'V' : '-';
	str[1] = '\0';

	return str;
}

/*===========================================================================*
 *				image_dmp				     *
 *===========================================================================*/
void image_dmp()
{
  int m, r;
  struct boot_image *ip;
	
  if ((r = sys_getimage(image)) != 0) {
      report("IS","warning: couldn't get copy of image table", r);
      return;
  }
  printk("Image table dump showing all processes included in system image.\n");
  printk("---name- -nr- ----pc- flags -qs- -queue- -stack-\n");
  for (m=0; m<NR_BOOT_PROCS; m++) { 
      ip = &image[m];
      printk("%8s %4d %7lu %5s %4d %7d %7lu\n",
          ip->proc_name, ip->proc_nr, (long)ip->initial_pc,
          boot_flags_str(ip->flags), ip->quantum, ip->priority, ip->stksize); 
  }
  printk("\n");
}

/*===========================================================================*
 *				kenv_dmp				     *
 *===========================================================================*/
void kenv_dmp()
{
    struct kinfo kinfo;
    struct machine machine;
    int r;
    if ((r = sys_getkinfo(&kinfo)) != 0) {
    	report("IS","warning: couldn't get copy of kernel info struct", r);
    	return;
    }
    if ((r = sys_getmachine(&machine)) != 0) {
    	report("IS","warning: couldn't get copy of kernel machine struct", r);
    	return;
    }

    printk("Dump of kinfo and machine structures.\n\n");
    printk("Machine structure:\n");
    printk("- pc_at:      %3d\n", machine.pc_at); 
    printk("- ps_mca:     %3d\n", machine.ps_mca); 
    printk("- processor:  %3d\n", machine.processor); 
    printk("- vdu_ega:    %3d\n", machine.vdu_ega); 
    printk("- vdu_vga:    %3d\n\n", machine.vdu_vga); 
    printk("Kernel info structure:\n");
    printk("- code_base:  %5u\n", kinfo.code_base); 
    printk("- code_size:  %5u\n", kinfo.code_size); 
    printk("- data_base:  %5u\n", kinfo.data_base); 
    printk("- data_size:  %5u\n", kinfo.data_size); 
    printk("- proc_addr:  %5u\n", kinfo.proc_addr); 
    printk("- bootdev_base:  %5u\n", kinfo.bootdev_base); 
    printk("- bootdev_size:  %5u\n", kinfo.bootdev_size); 
    printk("- ramdev_base:   %5u\n", kinfo.ramdev_base); 
    printk("- ramdev_size:   %5u\n", kinfo.ramdev_size); 
    printk("- nr_procs:     %3u\n", kinfo.nr_procs); 
    printk("- nr_tasks:     %3u\n", kinfo.nr_tasks); 
    printk("- release:      %.6s\n", kinfo.release); 
    printk("- version:      %.6s\n", kinfo.version); 
    printk("\n");
}

/*===========================================================================*
 *			      s_flags_str				     *
 *===========================================================================*/
static char *s_flags_str(int flags)
{
	static char str[10];
	str[0] = (flags & PREEMPTIBLE)        ? 'P' : '-';
	str[1] = (flags & BILLABLE)           ? 'B' : '-';
	str[2] = (flags & DYN_PRIV_ID)        ? 'D' : '-';
	str[3] = (flags & SYS_PROC)           ? 'S' : '-';
	str[4] = (flags & CHECK_IO_PORT)      ? 'I' : '-';
	str[5] = (flags & CHECK_IRQ)          ? 'Q' : '-';
	str[6] = (flags & CHECK_MEM)          ? 'M' : '-';
	str[7] = '\0';

	return str;
}

/*===========================================================================*
 *			      s_traps_str				     *
 *===========================================================================*/
static char *s_traps_str(int flags)
{
	static char str[10];
	str[0] = (flags & (1 << KIPC_SEND))  ? 'S' : '-';
	str[1] = (flags & (1 << KIPC_SENDA)) ? 'A' : '-';
	str[2] = (flags & (1 << KIPC_RECEIVE))  ? 'R' : '-';
	str[3] = (flags & (1 << KIPC_SENDREC))  ? 'B' : '-';
	str[4] = (flags & (1 << KIPC_NOTIFY)) ? 'N' : '-';
	str[5] = '\0';

	return str;
}

/*===========================================================================*
 *				privileges_dmp 				     *
 *===========================================================================*/
void privileges_dmp()
{
  register struct proc *rp;
  static struct proc *oldrp = BEG_PROC_ADDR;
  register struct priv *sp;
  int r, i;

  /* First obtain a fresh copy of the current process and system table. */
  if ((r = sys_getprivtab(priv)) != 0) {
      report("IS","warning: couldn't get copy of system privileges table", r);
      return;
  }
  if ((r = sys_getproctab(proc)) != 0) {
      report("IS","warning: couldn't get copy of process table", r);
      return;
  }

  printk("-nr- -id- -name-- -flags-    traps  grants -ipc_to--  -kernel calls-\n");

  PROCLOOP(rp, oldrp)
        r = -1;
        for (sp = &priv[0]; sp < &priv[NR_SYS_PROCS]; sp++) 
            if (sp->s_proc_nr == rp->p_nr) { r ++; break; }
        if (r == -1 && !isemptyp(rp)) {
	    sp = &priv[USER_PRIV_ID];
        }
	printk("(%02u) %-7.7s %s    %s %7d",
	       sp->s_id, rp->p_name,
	       s_flags_str(sp->s_flags), s_traps_str(sp->s_trap_mask),
		sp->s_grant_entries);
        for (i=0; i < NR_SYS_PROCS; i += BITCHUNK_BITS) {
	    printk(" %04x", get_sys_bits(sp->s_ipc_to, i));
       	}

	printk("              ");
        for (i=0; i < NR_SYS_CALLS; i += BITCHUNK_BITS) {
	    printk(" %04x", sp->s_k_call_mask[i/BITCHUNK_BITS]);
    	}
        printk("\n");

  }
}

/*===========================================================================*
 *			       p_rts_flags_str 				     *
 *===========================================================================*/
static char *p_rts_flags_str(int flags)
{
	static char str[10];
	str[0] = (flags & RTS_PROC_STOP) ? 's' : '-';
	str[1] = (flags & RTS_SENDING)  ? 'S' : '-';
	str[2] = (flags & RTS_RECEIVING)    ? 'R' : '-';
	str[3] = (flags & RTS_SIGNALED)    ? 'I' : '-';
	str[4] = (flags & RTS_SIG_PENDING)    ? 'P' : '-';
	str[5] = (flags & RTS_P_STOP)    ? 'T' : '-';
	str[6] = (flags & RTS_NO_PRIV) ? 'p' : '-';
	str[7] = '\0';

	return str;
}

/*===========================================================================*
 *				proctab_dmp    				     *
 *===========================================================================*/
#ifdef CONFIG_X86_32
void proctab_dmp()
{
/* Proc table dump */

  register struct proc *rp;
  static struct proc *oldrp = BEG_PROC_ADDR;
  int r;
  phys_clicks text, data, size;

  /* First obtain a fresh copy of the current process table. */
  if ((r = sys_getproctab(proc)) != 0) {
      report("IS","warning: couldn't get copy of process table", r);
      return;
  }

  printk("\n-nr-----gen---endpoint-name--- -prior-quant- -user----sys-rtsflags-from/to-\n");

  PROCLOOP(rp, oldrp)
	text = rp->p_memmap[T].mem_phys;
	data = rp->p_memmap[D].mem_phys;
	size = rp->p_memmap[T].mem_len
		+ ((rp->p_memmap[S].mem_phys + rp->p_memmap[S].mem_len) - data);
	printk(" %5d %10d ", _ENDPOINT_G(rp->p_endpoint), rp->p_endpoint);
	printk("%-8.8s %02u/%02u %02d/%02u %6lu %6lu ",
	       rp->p_name,
	       rp->p_priority, rp->p_max_priority,
	       rp->p_ticks_left, rp->p_quantum_size, 
	       rp->p_user_time, rp->p_sys_time);
	PRINTRTS(rp);
	printk("\n");
  }
}
#endif /* CONFIG_X86_32 */

/*===========================================================================*
 *				procstack_dmp  				     *
 *===========================================================================*/
void procstack_dmp()
{
/* Proc table dump, with stack */

  register struct proc *rp;
  static struct proc *oldrp = BEG_PROC_ADDR;
  int r;

  /* First obtain a fresh copy of the current process table. */
  if ((r = sys_getproctab(proc)) != 0) {
      report("IS","warning: couldn't get copy of process table", r);
      return;
  }

  printk("\n-nr-rts flags--      --stack--\n");

  PROCLOOP(rp, oldrp)
	PRINTRTS(rp);
	sys_sysctl_stacktrace(rp->p_endpoint);
  }
}

/*===========================================================================*
 *				memmap_dmp    				     *
 *===========================================================================*/
void memmap_dmp()
{
  register struct proc *rp;
  static struct proc *oldrp = proc;
  int r;
  phys_clicks size;

  /* First obtain a fresh copy of the current process table. */
  if ((r = sys_getproctab(proc)) != 0) {
      report("IS","warning: couldn't get copy of process table", r);
      return;
  }

  printk("\n-nr/name--- --pc--   --sp-- -text---- -data---- -stack--- -cr3-\n");
  PROCLOOP(rp, oldrp)
	size = rp->p_memmap[T].mem_len
		+ ((rp->p_memmap[S].mem_phys + rp->p_memmap[S].mem_len)
						- rp->p_memmap[D].mem_phys);
	printk("%-7.7s%7lx %8lx %4x %4x %4x %4x %5x %5x %8lx\n",
	       rp->p_name,
	       (unsigned long) rp->p_reg.pc,
	       (unsigned long) rp->p_reg.sp,
	       rp->p_memmap[T].mem_phys, rp->p_memmap[T].mem_len,
	       rp->p_memmap[D].mem_phys, rp->p_memmap[D].mem_len,
	       rp->p_memmap[S].mem_phys, rp->p_memmap[S].mem_len,
	       rp->p_seg.p_cr3);
  }
}

/*===========================================================================*
 *				proc_name    				     *
 *===========================================================================*/
static char *proc_name(proc_nr)
int proc_nr;
{
  struct proc *p;
  if (proc_nr == ENDPT_ANY) return "ANY";
  if (proc_nr == ENDPT_NONE) return "NONE";	/* bogus */
  if (proc_nr < -NR_TASKS || proc_nr >= NR_PROCS) return "BOGUS";
  p = cproc_addr(proc_nr);
  if (isemptyp(p)) return "EMPTY";	/* bogus */
  return p->p_name;
}

